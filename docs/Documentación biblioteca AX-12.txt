Todas las funciones de comunicación con el motor, por ejemplo writeData() o readData() retornan un byte llamado "error interno", y setean 3 variables globales int, que son:
 
status_id
status_error
status_data
 
Si error interno != 0, entonces estas 3 variables valen -1, de lo contrario, almacenan lo que viene del AX-12 mismo, o sea el ID del motor que respondió, el código de error del AX-12 y el valor, cuando es una operación de lectura, de lo contrario 0.
 
No me gusta mucho usar variables globales, quedaría más prolijo si toda la biblioteca fuera una clase. Voy a intentarlo.
 
Aquí van los códigos de error:

 
Decodificación de error (AX-12):
    
   error interno:
      Bit 0 = Error de Cabecera (falta byte de cabecera = 255)
      Bit 1 = Error de Coherencia (el largo del mensaje difiere de lo esperado)
      Bit 2 = Error de Checksum (el checksum es incorrecto)
 
   status_error:
      Bit 6 = Instruction Error (undefined instruction is sent or an action instruction is sent without a Reg_Write instruction)
      Bit 5 = Overload Error (the specified maximum torque can't control the applied load)
      Bit 4 = Checksum Error (the checksum of the instruction packet is incorrect)
      Bit 3 = Range Error (the instruction sent is out of the defined range)
      Bit 2 = Overheating Error (the internal temperature of the Dynamixel unit is above the operating temperature range as defined in the control table)
      Bit 1 = Angle Limit Error (the Goal Position is set outside of the range between CW Angle Limit and CCW Angle Limit)
      Bit 0 = Input Voltage Error (the voltage is out of the operating voltage range as defined in the control table)



Nuevas mejoras en la biblioteca AX12
 
1) ahora es una clase AX12. Se puede instanciar varias veces, para cada motor distinto; al hacerlo le pasamos el ID y después ya no hay que ponerlo en cada mensaje. Además elimina el uso de las variables globales
 
2) en los #defines, saqué todos los prefijos "AX", saqué todos los bytes altos de los parámetros de 2 bytes, eliminé las direcciones que son reservadas y me cercioré de que los nombres aparezcan exactamente como en el manual
 
3) 2 nuevos métodos "readInfo" y "writeInfo", para sustituir a los antiguos "readData" y "writeData". La diferencia es que a estos nuevos métodos no hay que pasarles el largo del parámetro, "saben" qué direcciones son de 1 byte y cuáles son de 2 bytes. Además "saben" que direcciones son de lectura/escritura y cuáles son de sólo lectura. Esto sumado a la eliminación del ID en los mensajes, hace que el manejo de los motores sea bastante más sencillo, sin sacrificar ninguna funcionalidad. 
 
Un ejemplo de manejo con la nueva biblioteca:
 
AX12 motor_izq (1000000, 14);
motor_izq.writeInfo (GOAL_POSITION, 512);
motor_izq.readInfo (PRESENT_TEMPERATURE);
etc.


Nuevas nuevas mejoras:

1) admite 5 constructores distintos:

    AX12 (long baud, byte motor_id, boolean inv);
    AX12 (byte motor_id, boolean inv);
    AX12 (long baud, byte motor_id);
    AX12 (byte motor_id);
    AX12 (); 

2) el método AX12_init(long baud) es estático (igual que buena parte de la biblioteca) y puede ser llamado incluso sin haber instanciado ningún motor. Gracias a esto y a la posibilidad de instanciar sin definir el baudrate, se evita que esta rutina sea llamada varias veces.

3) nuevo método estático: autodetect (int *list_motors, byte num_motors), detecta automáticamente las ID de los motores conectados. 

4) nuevos métodos:

    void setEndlessTurnMode (boolean onoff);
    void endlessTurn (int velocity, boolean direction);

5) nuevos defines: CW y CCW se pueden usar para la dirección en el movimiento continuo. La dirección se ve afectada por la propiedad "inverse" del motor.


Nueva mejora:

agregamos a setRX() y setTX(), el método setNone(), que lo deja en estado neutro. Antes quedaba siempre en RX y bloqueaba las interrupciones, se trancaba con los delay() largos y con la NewSoftSerial. Ahora anda con la NewSoftSerial a 115200.
 
Se agregó:

 * presentPSL

Próximamente:

 * vamos a implementar lo de los distintos modos de respuesta <-- no me acuerdo qué era esto (19-6-10)


19-6-12:

La biblioteca es compatible con todas las placas Arduino

- placas basadas en ATmega8, ATmega168 y ATmega328P (USB, NG, Diecimila, Duemilanove, etc.): 
  la bliblioteca AX12 utiliza el serial0 y no se puede usar junto con la Serial de Arduino.

- placas basadas en ATmega1280 (Mega) y ATmega128 (Wiring):
  la bliblioteca AX12 utiliza el serial1 y se puede usar junto con la Serial de Arduino, pero es necesario  
  poner la versión modificada de HardwareSerial.cpp en el core de Arduino.

