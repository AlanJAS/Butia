Uno de los requerimientos de la plataforma es ser altamente portable. Se espera que Buti\'a soporte al menos las siguientes plataformas:

\begin{itemize}
\item OLPC XO. Este es la plataforma del Plan Ceibal. El hardware contiene un procesador AMD Geode, con arquitectura x86. Los primeros modelos poseían 256Mb RAM. El disco duro es de estado s\'olido. El software consiste en un kernel Linux con Sugar como interfaz de usuario. 
\item Intel Classmate. Es la plataforma para enseñanza de Intel, y es un nombre gen\'erico para una línea de productos de distintos fabricantes. El hardware es t\'ipico para un Netbook de bajo costo: procesador Intel Atom (x86), a partir de 512Mb de RAM, disco duro magn\'etico.
\item Router Inal\'ambrico. Plataforma de costo y poder de c\'omputo m \'inimo prevista. Un ejemplo típico es un router Asus 520GU. Conssite en un sistema embebido con un procesador Broadcomm, con 32Mb de RAM y 8Mb de almacenamiento Flash. En nuestro uso, se le instala OpenWRT, una distribuci\'on de Linux para sistemas embebidos.
\item Smartphones. Hay multitud de fabricantes y de plataformas de software. Usualmente contienen un procesador ARM, más de 64Mb de RAM y almacenamiento flash. El sistema operativo puede estar basado en Linux, Windows ME, u otros sistemas dedicados.
\end{itemize}

Se plantea la necesidad de disponer de un componente que pueda ser desplegado con m\'inimas modificaciones en todas las plataformas de interés, y que implemente las siguientes funcionalidades:

\begin{itemize}
\item Acceda a la placa del Microprocesador implementando el protocolo \textit{USB4all} sobre el tipo de conexi\'on asociado (USB o Serial)
\item Ofrezca una API que permita acceder las funcionalidades provistas por Butiá desde las aplicaciones de usuario.
\end{itemize}

Este componente se implementó en dos partes: una librería que implementa la comunicación con la placa (\textit{bobot}, y una aplicación que usa esta librería y exporta su funcionalidad mediante un socket (\textit{bobot-server}). Esta solución es la solución de referencia, de máxima portabilidad. Para plataformas específicas es perfectamente posible desarrollar soluciones particulares.

Este componente se implementó en Lua. Este es un lenguaje de scripting dinámico basado en una máquina virtual. Está escrito en ANSI C99 por lo que es altamente portable, y es muy compacto: la máquina virtual ocupa unos 800kb de RAM. Es un lenguaje muy eficiente y provee varias funcionalidades potentes, tales como expresiones regulares, mapas asociativos basados en hash, funciones como miembros de primera clase, etc.

\subsubsection*{bobot}

Como se mencionó, esta librería accede la placa microcontroladora mediante USB o Serial. Para lo primer opci\'on, se enlaza con libusb, una librería portable de espacio de usuario para manipular dispositivos USB. Este enlace se realiza mediante un binding desarrollado, llamado \textit{lualibusb}. Para acceder mediante serial se utiliza una pequeña librería en C que implementa una comunicación orientada a mensajes sobre Serial llamada \textit{serialcomm}.
Esta librería es fácilmente extensible para agregar soporte a nuevos módulos de la placa controladora (\textit{USB4all/Arduinoi}). Esto se logra mediante drivers cargados dinámicamente de acuerdo a los módulos declarados por la placa controladora. Para agregar soporte para un nuevo módulo, basta con agregar el driver apropiado a la directorio de drivers.
\subsubsection*{bobot-server}

Esta aplicaci\'on exporta la funcionalidad subyacente de Buti\'a a las aplicaciones de usuario. Lo hace mediante un protocolo muy sencillo en un socket TCP (por defecto en el puerto 2009). Para utilizarlo las aplicaciones de usuario deben abrir una conexi\'on TCP, e implementar dicho protocolo. Los mensajes soportados por bobot-server son:

 \texttt{LIST}
Devuelve la lista de m\'odulos detectados, separados por comas.
 
\texttt{OPEN module [ep1 ep2]}
Abre el m\'odulo. Si es necesario o no, depende del modulo. Devuelve
"ok" o "fail". 

\texttt{DESCRIBE module [ep1 ep2]}
Devuelve una descripci\'on de la API del modulo.

\texttt{CALL module  function [parameters ...]}
Invoca la funci\'on indicada en el m\'odulo dado. Los par\'ametros dependen de
la funci\'on. Devuelve la respuesta de la llamada, o "fail".

\texttt{CLOSEALL}
Cierra todos los m\'odulos. En general no hace falta. Devuelve "ok"









